## 1. 외부 데이터 연동 및 수집
**쟁점:** 비동기 데이터 요청, 캐싱, 서버 상태 관리의 효율성 및 코드 복잡성 최소화 방안

### 🆚 기술 전략 비교
| 전략(Strategy) | 제안자 | 장점 (Pros) | 단점 (Cons) |
|---|---|---|---|
| **TanStack Query (React Query)** | Reviewer | 서버 상태 관리가 용이하며, 캐싱, 재시도, 동기화 등 고급 기능이 내장되어 보일러플레이트 코드를 크게 줄임. | 라이브러리 학습 곡선이 존재하며, 간단한 요청에는 과도한 의존성이 될 수 있음. |
| useEffect + fetch | Reviewee | 별도 라이브러리 없이 React 내장 기능만으로 구현 가능. 가볍고 직관적임. | 로딩/에러 상태, 캐싱, 재요청 로직을 수동으로 구현해야 하므로 코드가 복잡해지고 반복이 많아짐. |

### 💡 Dominant Strategy: TanStack Query (React Query)
**선택 이유:** 반복적인 데이터 fetching 로직의 복잡성을 줄이고, 캐싱 전략을 통해 서버 부하 감소 및 사용자 경험 향상이 기대됨. 장기적인 유지보수 관점에서 더 유리하다고 판단됨.

---

## 2. 전역 상태 관리
**쟁점:** 애플리케이션 전반의 상태(사용자 인증, UI 테마 등)를 일관성 있게 관리하기 위한 라이브러리 선정

### 🆚 기술 전략 비교
| 전략(Strategy) | 제안자 | 장점 (Pros) | 단점 (Cons) |
|---|---|---|---|
| Redux Toolkit | Reviewee | 강력한 개발자 도구, 예측 가능한 상태 관리, 미들웨어를 통한 확장성이 뛰어남. 대규모 애플리케이션에 적합. | Zustand 대비 상대적으로 많은 보일러플레이트 코드. 초기 설정이 복잡하게 느껴질 수 있음. |
| **Zustand** | Reviewer | 매우 적은 보일러플레이트, 간결한 API, Context Provider가 필요 없어 구현이 간단함. | 미들웨어 생태계나 개발자 도구가 Redux만큼 성숙하지 않음. 복잡한 비동기 로직 처리가 상대적으로 번거로울 수 있음. |

### 💡 Dominant Strategy: Zustand
**선택 이유:** 프로젝트 규모가 크지 않고, 인증 상태와 같은 단순 전역 상태 관리가 주 목적이므로, Redux Toolkit의 복잡성보다 Zustand의 간결함과 빠른 개발 속도가 더 큰 이점을 제공함.

---

## 3. 컴포넌트 스타일링 전략
**쟁점:** CSS 작성 방식의 효율성, 유지보수성, 그리고 디자인 시스템과의 일관성 확보 방안

### 🆚 기술 전략 비교
| 전략(Strategy) | 제안자 | 장점 (Pros) | 단점 (Cons) |
|---|---|---|---|
| **Tailwind CSS** | Reviewer | 미리 정의된 유틸리티 클래스 사용으로 빠른 개발 속도. 클래스명 고민 불필요. 일관된 디자인 시스템 구축에 용이. | HTML 클래스 속성이 길고 복잡해질 수 있음. 유틸리티 클래스 학습이 필요함. |
| Styled-Components (CSS-in-JS) | Reviewee | 컴포넌트 단위로 스타일을 격리하여 관리. JavaScript 변수 및 로직을 스타일에 동적으로 활용하기 용이. | 런타임 오버헤드 발생 가능성. 별도 라이브러리 의존성 추가. |

### 💡 Dominant Strategy: Tailwind CSS
**선택 이유:** 디자인 시스템의 일관성을 유지하고 개발 생산성을 높이는 데 더 효과적이라고 판단됨. 클래스명 작성에 대한 컨벤션 논의 비용을 줄일 수 있는 장점이 큼.